# Архитектура

## Что такое Theatrum? {id="what-is-theatrum"}
Theatrum — это в первую очередь стандарт для разработки API-методов.
Пусть у него нет четкой спецификации или RFC, однако это не делает его менее эффективным.
В основе стандарта лежат принципы разработки методов, которые появились в ходе
работы над десятками приложений уровня Enterprise. Эти принципы универсальны, имеют
архитектурную природу и могут применяться при разработке на любом языке программирования.

Данная библиотека предоставляет удобные инструменты для разработки бекенда по этим принципам
конкретно в TypeScript и JavaScript.

## Философия Theatrum {id="philosophy"}
> Для удобства далее будем называть API-метод просто методом.
> Можете смело поставить знак равенства между этими понятиями в рамках данной страницы.

### 1. Любой метод — это функция
Главная задача любого бекенд-приложения состоит в реализации некоторой бизнес-логики.
Эта бизнес-логика чаще всего является несложной и её можно описать формулой:
`входные параметры + действия = результат`. Это ничто иное как классическая функция,
которая есть в любом языке программирования.

Однако, к таким функциям мы выдвигаем несколько требований:
* Функция должна решать ровно одну задачу.
* Функция должна возвращать результат.
* Описать то, что делает функция можно глаголом + существительным: например, "создаёт пользователя" или "отправляет уведомление".

```d2
direction: right

f: Метод
f.input: Входные данные
f.actions: Действия
f.result: Результат
input: .
result: .

input.style.opacity: 0
result.style.opacity: 0

input-> f.input

f.input->f.actions {
    style.animated: true
}

f.actions->f.result {
    style.animated: true
}

f.result -> result
```

### 2. Любой метод имеет параметры контекст
Параметры функции — это данные, которые передал пользователь при вызове метода.

Однако, любая функция не вызывается в вакууме, поэтому у каждой функции обязательно
должен быть контекст. Под контекстом мы понимаем те данные, которые могут повлиять
на поведение функции, но сам пользователь их напрямую не указывает.

Например, когда пользователь при вызове метода передаёт свой ключ доступа, ваш бекенд авторизует его и
ваш метод знает, что это за пользователь. Эта информация вычислена в ходе запроса. И самое важное, что
следует отметить, чтобы если вызвать этот метод с такими же параметрами, но используя другой ключ доступа,
то он может выполнить иные действия/вернуть другой результат, хотя код остался неизменным.

В Theatrum главным элементом контекста является информация о том, кто запустил метод.

```d2
direction: right

f: Метод
params: Пользовательские\nпараметры
context: Контекст
context.user: Информация\nо пользователе

params->f {
    style.animated: true
}

context->f {
    style.animated: true
}
```

### 3. Методы написаны под абстрактные сущности, но работают с акторами
Сущность — это тип пользователя, а актор — конкретный пользователь.
Для разграничения доступа у каждого актора дополнительно могут быть определены роли.

Примеры сущностей и акторов:
* Сущность `Сотрудник`, актор `Сотрудник №1`
* Сущность `Администратор`, актор `Администратор Иван`
* Сущность `Менеджер`, актор `Менеджер f6b22bea-9e30-4937-aa40-01a6cd571348`
* Сущность `Вебхук`, актор `Вебхук из Slack`
* Сущность `Устройство`, актор `Устройство 00:4A:77:98:3C:B4`

> Можно легко заметить, что актор - это сущность, в которую вдохнули жизнь - наполнили данными.
> Также проглядывается аналогия с паттерном `класс→объект`, где класс - это сущность, а объект - актор.

Важно, чтобы методы были универсальными и работали со всеми возможными акторами сущностей, которые они поддерживают,
однако это не означает, что функции при этом должны вернуть один и тот же результат.

Например: `Пользователь №1` и `Пользователь №2` могут вызвать один и тот же метод (если их набор ролей совпадает),
но для `Пользователя №1` он совершит нужное действие и вернет положительный результат, а для `Пользователя №2`
он вернет ошибку (например, из-за отсутствия верификации e-mail).

```d2
direction: left

entity: Сущность\nПользователь
entity.id: ID
entity.name: Имя
entity.phone: Телефон
entity.style.stroke-dash: 5
entity.*.style.stroke-dash: 5

actor: Актор\nПольватель №1
actor.id: 1
actor.name: Иван
actor.phone: +79991234567

entity.id<-actor.id {
    style.animated: true
}

entity.name<-actor.name {
    style.animated: true
}

entity.phone<-actor.phone {
    style.animated: true
}
```

### 4. Методы не должны реализовывать авторизацию
Методы реализуют логику, которую запускает пользователь на вашем сервере предварительно
пройдя все необходимые проверки. Такой способствует реализации идентификации, аутентификации
и авторизации один раз, перед вызовом методов.

> Методы работают уже с готовой информацией, которой можно доверять и можно сразу использовать.
> Это позволяет уменьшить количество бойлерплейт кода.

В данной библиотеке мы уже реализовали за вас механизм авторизации: проверки разрешения на запуск методов
на основе акторов (и их ролей). Также мы сделали инструменты для валидации пользовательских параметров на
основе [Zod](https://zod.dev).

```d2
direction: right

user: Реализует\nпользователь
theatrum: Реализует\nTheatrum

user.id: Идентификация
user.authn: Аутентификация
theatrum.authz: Авторизация

user.id->user.authn

user.authn->theatrum.authz {
    style.animated: true
}

```

### 5. Один метод может вызвать другой метод
Чтобы не было необходимости создавать дополнительные абстракции или реализовывать одну и ту же логику повторно,
методы должны уметь вызывать другие методы.

Работает это очень просто: при вызове `Метода B` из `Метода A` в него передаются необходимые вам данные и контекст,
в котором был запущен `Метод A`. Это позволяет не писать дополнительную логику внутри `Метода B`: для него это будет
выглядеть как обычный вызов из вне, однако его результат будет передан в `Метод A`, где дальше может быть обработан.

Пример: при создании пользователя в методе `orders.create` нам необходимо отправить ему смс-сообщение информацией
о покупке. Мы можем вызвать метод `sms.send` и передать в него номер телефона пользователя вместе с текстом
сообщения. Этот метод поставит задачу на отправку смс в очередь, а мы вернем пользователю ответ об успешном
оформлении заказа.

Также, вы можете выносить в отдельные методы логику валидации данных и вообще любую другую общую логику.

```d2
direction: right

user: Пользователь\n(Актор)
f1: orders.create
f2: sms.send
queue: .

queue.style.opacity: 0

user->f1: 1. Создай заказ

f1->f2: 2. Отправь смс {
    style.animated: true
}

f2->queue: 3. Отправь смс

f2->f1: 4. OK {
    style.animated: true
}

f1->user: 5. Номер заказа
```

## Пример работы {id="example"}
Рассмотрим работу Theatrum на примере одного запроса.
В начале у нас есть объект `theatrum`, который мы создали.
Он содержит список всех методов и сущностей.

```d2
direction: right

entities: Сущности
entities.style.multiple: true
methods: Методы
methods.style.multiple: true
theatrum: Theatrum
theatrum.entities: Сущности
theatrum.entities.style.multiple: true
theatrum.methods: Методы
theatrum.methods.style.multiple: true

entities->theatrum.entities: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
methods->theatrum.methods: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
```

Для запроса нам также потребуется актор. Создать его можно
непосредственно из объекта `theatrum`.

> Стоит отдельно отметить, что актор — это производный объект от сущности,
> поэтому, чтобы создать актора, сущность которой он принадлежит, должна быть
> передана в `theatrum` при создании.

```d2
direction: right

theatrum: Theatrum
theatrum.entities: Сущности
theatrum.entities.style.multiple: true
theatrum.methods: Методы
theatrum.methods.style.multiple: true
actor: Актор

theatrum.entities->actor: Является родителем {
    style.animated: true
    style.stroke-dash: 3
}
theatrum->actor: Создает
```

Чтобы вызвать метод, требуется создать исполнителя. Для его работы требуется актор.
Мы будем использовать тот, что только что создали.

```d2
direction: right

theatrum: Theatrum
theatrum.entities: Сущности
theatrum.entities.style.multiple: true
theatrum.methods: Методы
theatrum.methods.style.multiple: true
actor: Актор
executor: Исполнитель
executor.methods: Методы
executor.methods.style.multiple: true
executor.actor: Актор

theatrum->executor: Создает
theatrum.methods->executor.methods: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
actor->executor.actor: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
```

Теперь, когда у нас есть исполнитель, можно вызвать нужный метод от имени актора.
Для этого используется функция исполнителя `run`.

```d2
direction: right

req: "run('math.sum', { a: 5, b: 4 })"
executor: Исполнитель
executor.methods: Методы
executor.methods.style.multiple: true
executor.actor: Актор

req->executor
```

Сразу после вызова функции `run`, исполнитель находит нужный метод по переданному
названию и, после ряда проверок, вызывает его, если они успешно пройдены. При вызове
метода в него передаются параметры, переданные в функцию `run`, и контекст исполнителя.

```d2
direction: right

executor: Исполнитель
executor.methods: Методы
executor.methods.style.multiple: true
executor.actor: Актор
context: Контекст
context.actor: Актор
method: Метод
method.context: Контекст

executor->context: Создает
executor.actor->context.actor: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
context->method.context: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
executor->method: "Вызывает с\n{ a: 5, b: 4 }"
```

После того как метод был вызван, он проверяет переданные в него параметры и,
если они являются корректными, вызывает обработчик с пользовательской
бизнес-логикой.

```d2
direction: right

method: Метод
method.params: "Параметры запроса\n{ a: 5, b: 4 }"
method.context: Контекст
method.context.actor: Актор
handler: Обработчик

method.params->handler: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
method->handler: Вызывает
method.context->handler: Используется в {
    style.animated: true
    style.stroke-dash: 3
}
```

Теперь, если рассмотреть обработчик (ваша бизнес-логика), то
у вас есть доступ к:
* Проверенному актору (вы его аутентифицировали ранее, theatrum авторизовал его для запуска метода)
* Проверенным параметрам (согласно спецификации метода)

При этом неважно какой именно актор запустил ваш обработчик: если
это случилось, то у актора гарантированно были полномочия это сделать
(исходя из его `entity` и набора ролей). Параметры, которые доступны
в вашем обработчике, прошли все предварительные проверки и гарантировано
соответствуют вашей спецификации метода.

Вы можете использовать эти все данные сразу в вашей бизнес-логике
или провести дополнительные проверки: например, если метод может быть
вызван сущностями `User` и `Admin`, то при вызове от имени `User`
будет возвращена только базовая информация, а при вызове от имени `Admin`
будет возвращена более обогащенная информация.

```d2
direction: right
params: "Параметры запроса ✅\n{ a: 5, b: 4 }"
context: Контекст
context.actor: Актор ✅
handler: Обработчик

context->handler {
    style.animated: true
    style.stroke-dash: 3
}
params->handler {
    style.animated: true
    style.stroke-dash: 3
}
```

Вернемся к нашему примеру. Как только обработчик успешно завершит свое
выполнение, он вернет результат в метод, тот в свою очередь передаст его
исполнителю, а от туда он вернется пользователю.

```d2
direction: left

handler: Обработчик
method: Метод
executor: Исполнитель
external: ""
external.style.opacity: 0


method<-handler: Результат\n9
executor<-method: Результат\n9
external<-executor: Результат\n9 {
    style.animated: true
    style.stroke-dash: 3
}
```
